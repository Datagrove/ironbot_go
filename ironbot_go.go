package ironbot_go

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
)

// the point of a certification program is to confirm that challenges
// were passed.

// this cert bot accepts the challenges directly from standard in.
// cert bots (like data bots) may instead accept file names of temp files
// that hold the data.

type CertificationRequest struct {
	// the unique Id is generated by ironwood. You may store this id
	// and use it to revoke a certification before it expires.
	Id     string
	Secret string // not confirmed; this may be a member id or a qr scan
	Phone  string `json:"phone,omitempty"`
	Email  string `json:"email,omitempty"`
	// You may ask the user questions (Mother's maiden name, etc)
	// these are in the configuration and are keys that you pick.
	Questions map[string]string
}
type Certification struct {
	CertifiedSeconds int64       `json:"expires,omitempty"`
	LockedSeconds    int64       `json:"locked_seconds,omitempty"`
	Secret           string      `json:"secret,omitempty"`
	Challenge        []Challenge // pass one of these challenges
}

const (
	Phone = "phone"
	Email = "email"
)

type Challenge struct {
	Type   string
	Prompt any
}

// basic loop

type CertifyFn = func(in *CertificationRequest, out *Certification) error

func CertifyBot(fn CertifyFn) error {
	reader := bufio.NewReader(os.Stdin)
	for {
		challenge, e := reader.ReadString('\n')
		if e != nil {

		}
		fmt.Scanln(challenge)
		var in CertificationRequest
		json.Unmarshal([]byte(challenge), &in)
		b, _ := json.Marshal(&CertificationRequest{})

		os.Stdout.Write(append(b, byte('\n')))
	}
}

func AnswerBot[In any, Out any](fn func(in *In, out *Out)) {

}
